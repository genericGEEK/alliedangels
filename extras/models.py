from PIL import Image

from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.core.validators import FileExtensionValidator
from django.core.exceptions import ValidationError
from django.core.cache import cache
from django.db import models
from django.utils import timezone

from .utils import image_upload, ALLOWED_IMAGE_EXTENSIONS, validate_landscape_image, process_image_to_jpeg


ALLOWED_IMAGE_EXTENSIONS = ["jpg", "jpeg", "png", "webp"]


class TimeStampedModel(models.Model):
    """
    An Abstract model which adds fields to store the creation and last-updated times for an object. Both fields can be
    null to facilitate adding these fields to existing instances via a database migration.
    """
    created_at = models.DateTimeField(
        default=timezone.now,
        blank=True,
        null=True
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        blank=True,
        null=True
    )
    class Meta:
        abstract = True


# --- Site-wide settings (singleton) ---
class SiteSettings(models.Model):
    site_name = models.CharField(max_length=120, default="Allied Angels")
    tagline = models.CharField(max_length=200, blank=True)

    # Contact
    email = models.EmailField(blank=True)
    phone = models.CharField(max_length=40, blank=True)
    address_line1 = models.CharField(max_length=120, blank=True)
    address_line2 = models.CharField(max_length=120, blank=True)
    city = models.CharField(max_length=80, blank=True)
    state = models.CharField(max_length=80, blank=True)
    postal_code = models.CharField(max_length=20, blank=True)

    # Socials
    facebook_url = models.URLField(blank=True)
    x_url = models.URLField(blank=True)
    instagram_url = models.URLField(blank=True)
    linkedin_url = models.URLField(blank=True)
    youtube_url = models.URLField(blank=True)

    # Branding (optional)
    #logo_light = models.ImageField(upload_to="branding/", blank=True, null=True)
    #logo_dark  = models.ImageField(upload_to="branding/", blank=True, null=True)
    #favicon    = models.ImageField(upload_to="branding/", blank=True, null=True)

    class Meta:
        verbose_name = "Site settings"
        verbose_name_plural = "Site settings"

    def __str__(self):
        return "Site settings"

    # --- Singleton helpers ---
    @classmethod
    def load(cls):
        """
        Cached getter. Keeps a single DB hit (and fast templates).
        """
        key = "site_settings_singleton"
        obj = cache.get(key)
        if obj is None:
            obj, _ = cls.objects.get_or_create(pk=1)
            cache.set(key, obj, 60)  # cache for 60s; bump if you like
        return obj

    def save(self, *args, **kwargs):
        self.pk = 1  # force singleton
        super().save(*args, **kwargs)
        cache.delete("site_settings_singleton")


class ImageAttachment(TimeStampedModel):
    """
    Reusable image attached to ANY model via GenericForeignKey.
    """
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    parent = GenericForeignKey("content_type", "object_id")
    image = models.ImageField(
        upload_to=image_upload,
        null=True,
        blank=True,
        validators=[
            FileExtensionValidator(ALLOWED_IMAGE_EXTENSIONS),
            validate_landscape_image,
        ],
    )

    # Display/SEO/accessibility
    alt_text = models.CharField(max_length=200, blank=True)
    caption = models.CharField(max_length=300, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["content_type", "object_id"]),
        ]

    def __str__(self):
        return f"ImageAttachment({self.content_type.model}:{self.object_id})"

    def clean(self):
        super().clean()

        if not self.image:
            return

        # Validate it's an image + landscape
        #validate_landscape_image(self.image)

    def save(self, *args, **kwargs):
        """
        Requirement #1:
        Resize/compress before saving so we don't store huge files.
        """
        if self.image and not getattr(self.image, "_processed", False):
            # enforce landscape again at save time (defense-in-depth)


            processed = process_image_to_jpeg(self.image)

            # Keep filename generated by upload_to (label-oid-uuid.jpg)
            # If the current name isn't .jpg, force it
            name = self.image.name
            if not name.lower().endswith(".jpg"):
                name = name.rsplit(".", 1)[0] + ".jpg"

            self.image.save(name, processed, save=False)
            self.image._processed = True

        super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        """
        Requirement #4:
        Remove the stored object from S3 (or local storage) when the attachment row is deleted.
        """
        if self.image:
            self.image.delete(save=False)
        return super().delete(*args, **kwargs)

    def is_orphan(self) -> bool:
        """
        True if nothing references this ImageAttachment anymore.
        """
        return (not self.event.exists()) and (not self.event_series.exists())
